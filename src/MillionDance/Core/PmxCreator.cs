using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;
using MillionDance.Entities.Internal;
using MillionDance.Entities.Pmx;
using MillionDance.Entities.Pmx.Extensions;
using MillionDance.Extensions;
using MillionDance.Utilities;
using UnityStudio.UnityEngine;
using UnityStudio.UnityEngine.Animation;
using Vector3 = OpenTK.Vector3;
using Vector4 = OpenTK.Vector4;

namespace MillionDance.Core {
    public static class PmxCreator {

        public static PmxModel Create([NotNull] Avatar combinedAvatar, [NotNull] Mesh combinedMesh, int bodySubMeshCount, [NotNull] string texturePrefix) {
            var model = new PmxModel();

            model.Name = "ミリシタ モデル00";
            model.NameEnglish = "MODEL_00";
            model.Comment = "製作：MillionDance";
            model.CommentEnglish = "Generated by MillionDance";

            var vertexCount = combinedMesh.VertexCount;
            var vertices = new PmxVertex[vertexCount];

            for (var i = 0; i < vertexCount; ++i) {
                var vertex = new PmxVertex();

                var position = combinedMesh.Vertices[i];
                var normal = combinedMesh.Normals[i];
                var uv = combinedMesh.UV1[i];

                vertex.Position = position.ToOpenTK().FixUnityToOpenTK() * ConversionConfig.ScaleUnityToMmd;
                vertex.Normal = normal.ToOpenTK().FixUnityToOpenTK();

                // Invert UV!
                vertex.UV = new OpenTK.Vector2(uv.X, 1 - uv.Y);

                vertex.EdgeScale = 1.0f;

                var skin = combinedMesh.Skin[i];
                var affectiveInfluenceCount = skin.Count(inf => inf != null);

                switch (affectiveInfluenceCount) {
                    case 1:
                        vertex.Deformation = Deformation.Bdef1;
                        break;
                    case 2:
                        vertex.Deformation = Deformation.Bdef2;
                        break;
                    case 3:
                        throw new NotSupportedException();
                    case 4:
                        vertex.Deformation = Deformation.Bdef4;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(affectiveInfluenceCount));
                }

                for (var j = 0; j < affectiveInfluenceCount; ++j) {
                    var boneId = combinedMesh.BoneNameHashes[skin[j].BoneIndex];
                    var realBoneIndex = combinedAvatar.AvatarSkeleton.NodeIDs.FindIndex(boneId);

                    if (realBoneIndex < 0) {
                        throw new ArgumentOutOfRangeException(nameof(realBoneIndex));
                    }

                    vertex.BoneWeights[j].BoneIndex = realBoneIndex;
                    vertex.BoneWeights[j].Weight = skin[j].Weight;
                }

                vertices[i] = vertex;
            }

            model.Vertices = vertices;

            var indicies = new int[combinedMesh.Indices.Count];

            for (var i = 0; i < indicies.Length; ++i) {
                indicies[i] = unchecked((int)combinedMesh.Indices[i]);
            }

            model.FaceTriangles = indicies;

            var boneCount = combinedAvatar.AvatarSkeleton.NodeIDs.Length;
            var bones = new PmxBone[boneCount];

            var hierachy = BoneUtils.BuildBoneHierarchy(combinedAvatar);

            for (var i = 0; i < bones.Length; ++i) {
                var bone = new PmxBone();
                var transform = combinedAvatar.AvatarSkeletonPose.Transforms[i];
                var boneNode = hierachy[i];

                string pmxBoneName;
                var mltdBoneName = boneNode.Path;

                if (BoneUtils.BoneNameMap.ContainsKey(mltdBoneName)) {
                    pmxBoneName = BoneUtils.BoneNameMap[mltdBoneName];
                } else {
                    // Prevent the name exceeding max length (15 bytes)
                    pmxBoneName = $"Bone #{mltdBoneName.GetHashCode():x8}";
                }

                bone.Name = pmxBoneName;
                bone.NameEnglish = BoneUtils.TranslateBoneName(pmxBoneName);

                // PMX's bone positions are in world coordinate system.
                // Unity's are in local coords.
                bone.InitialPosition = boneNode.InitialPositionWorld;
                bone.CurrentPosition = bone.InitialPosition;

                bone.ParentIndex = boneNode.Parent?.Index ?? -1;
                bone.BoneIndex = i;

                var singleDirectChild = boneNode.GetDirectSingleChild();

                if (singleDirectChild != null) {
                    bone.SetFlag(BoneFlags.ToBone);
                    bone.To_Bone = singleDirectChild.Index;
                } else {
                    // TODO: Fix this; it should point to a world position.
                    bone.To_Offset = transform.Translation.ToOpenTK().FixUnityToOpenTK();
                }

                // No use. This is just a flag to specify more details to rotation/translation limitation.
                //bone.SetFlag(BoneFlags.LocalFrame);
                bone.InitialRotation = transform.Rotation.ToOpenTK().FixUnityToOpenTK();
                bone.CurrentRotation = bone.InitialRotation;

                //bone.Level = boneNode.Level;
                bone.Level = 0;

                if (MovableBoneNames.Contains(mltdBoneName)) {
                    bone.SetFlag(BoneFlags.Rotation | BoneFlags.Translation);
                } else {
                    bone.SetFlag(BoneFlags.Rotation);
                }

                if (IsNameGeneratedName(boneNode.Path)) {
                    bone.ClearFlag(BoneFlags.Visible);
                }

                bones[i] = bone;
            }

            model.Bones = bones;

            var materialCount = combinedMesh.SubMeshes.Count;
            var materials = new PmxMaterial[materialCount];

            for (var i = 0; i < materialCount; ++i) {
                var material = new PmxMaterial();

                material.NameEnglish = material.Name = $"Mat #{i:00}";
                material.AppliedFaceVertexCount = (int)combinedMesh.SubMeshes[i].IndexCount;
                material.Ambient = Vector3.One;
                material.Diffuse = Vector4.One;
                material.Specular = Vector3.Zero;
                material.EdgeColor = new Vector4(0, 0, 0, 1);
                material.EdgeSize = 1.0f;
                // TODO: The right way: reading textures' path ID and do the mapping.
                material.TextureFileName = $"{texturePrefix}_{i:00}.png";

                material.Flags = MaterialFlags.Shadow | MaterialFlags.SelfShadow;

                materials[i] = material;
            }

            model.Materials = materials;

            return model;
        }

        [CanBeNull]
        private static BoneNode GetDirectSingleChild([NotNull] this BoneNode b) {
            var l = new List<BoneNode>();

            foreach (var c in b.Children) {
                var isGenerated = IsNameGeneratedName(c.Path);

                if (!isGenerated) {
                    l.Add(c);
                }
            }

            if (l.Count == 1) {
                return l[0];
            } else {
                return null;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsNameGeneratedName([NotNull] string name) {
            return CompilerGeneratedJointParts.Any(name.Contains);
        }

        private static readonly ISet<string> MovableBoneNames = new HashSet<string> {
            "",
            "POSITION",
            "MODEL_00",
            "MODEL_00/BASE"
        };

        private static readonly ISet<string> CompilerGeneratedJointParts = new HashSet<string> {
            "__rot",
            "__null",
            "__const",
            "__twist",
            "__slerp"
        };

    }
}
